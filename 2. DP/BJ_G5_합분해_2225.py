# https://www.acmicpc.net/problem/2225

#N,K = map(int,input().split())
N,K = 20,2
'''
0부터 N까지 정수 K개를 더해서 그 값이 N이 되는 경우의 수 구하기(단, 덧셈의 순서가 바뀐 경우는 다른 경우의 수로 카운트,한개의 수를 여러번 사용 가능)
- 0부터 20까지 2개를 더해서 그 값이 N이 되는 경우의 수
N     0  1  2  3  4  5  6  7  8   9  10  11  12  13  14  15  16  17  18  19  20
K=0  [0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0]
K=1  [1, 1, 1, 1, 1, 1, 1, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1], 1개로 나올 수 있는 값은 자신밖에 없어 경우의 수는 1  
K=2  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21]
    0+0(1가지) 
      0+1/1+0(2가지)
           0+2/1+1/2+0(3가지)
                       .....
                                                                         0+20/1+19/2+18/.../19+1/20+0(21가지)
점화식 : DP[K][N] = N(=DP[K][N-1]) + DP[K-1][N]

'''

dp = [[0] * (N+1) for _ in range(K+1)]  # 가로 : N, 세로 : K  dp[세로][가로]
for i in range(N+1): # K = 1일 경우, 경우의 수는 모든 수에 대해 1개임
    dp[1][i] = 1

for i in range(2,K+1):
    for j in range(N+1):
        dp[i][j] = dp[i][j-1] + dp[i-1][j]
print(dp)
print(dp[K][N]%1000000000)  # DP 값이 큰 값이 나올 경우  Overflow 를 방지하기 위해 문제에서 아래의 값으로 나눈 나머지를 출력하도록 함
