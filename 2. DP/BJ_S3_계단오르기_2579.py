# https://www.acmicpc.net/problem/2579
# 포도주(2156)와 스티커(9465) 문제와 같은 DP 문제
# 참조 : https://this-programmer.tistory.com/entry/%EB%B0%B1%EC%A4%802579%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B3%84%EB%8B%A8-%EC%98%A4%EB%A5%B4%EA%B8%B0

'''
계단오르기
- 한번에 한 계단씩 또는 두 계단씩 오를 수 있음
- 연속된 세 개의 계단을 모부 밟을 수 없음(시작점은 계단에 미포함)
- 마지막 도착 계단은 반드시 밟아야 함
P(N) =      [10,    20,     15,      25,         10,            20]
DP       0    1      2       3        4           5              6
              10    10+20   10+15            
                            20+15  10+20+25 
                                   10+15+25    20+15+10   
                                               10+20+25+10   10+20+25+20  (0 -> 1 -> 2 -> 4 -> 6)
                                                             20+15+10+20  (0 -> 2 -> 3 -> 5 -> 6)   

출력 : [10,  30,    35,        55,       65,             75,            0, 0, 0]                       

점화식 : DP[K] = max(DP[K-2],DP[K-3] + P[K]) + P[K]

'''
N = int(input()) # 계단 수
P = [0] * (N+3)   # N=1,2 인 경우를 위해 초기화

for i in range(1,N+1): 
    P[i] = int(input())

DP = [0] * (N+3)    # N=1,2인 경우를 위해 초기화

DP[1] = P[1]
DP[2] = P[1] + P[2] # P[0] 대신 DP[0]를 사용하면 안됨
DP[3] = max(P[2],P[1]) + P[3]
for i in range(4,N+1): # 현 계단까지 오는 경우의 수, 아래 점화식은 마지막 계단을 밟아야 한다라는 가정에서 생성
    DP[i] = max(DP[i-2],DP[i-3]+P[i-1]) + P[i]  # 2 계단 전에서 바로 오는 경우와 3 계단 전을 거쳐 전 계단을 통해 오는 경우의 최대값에 현재 점수를 더한 값
    print(DP)
print(DP[N])

