# https://www.acmicpc.net/problem/9527
# 참조 : https://degurii.tistory.com/158 
'''
문제에서 A와 B사이의 모든 x에 대해 이진수로 표기했을 때 1의 개수의 합을 구하는 문제로 누적합 문제라는 것을 알 수 있다.
하지만, A,B의 범위가 10^16까지 이므로 일반적인 세그먼트트리, 펜윅트리 알고리즘 적용이 불가하다.

f(x) = f(B)-f(A-1)

예) 2 12 ==> 2부터 12까지 이진수로 변환 후 1의 개수들을 누적합으로 구해야 함
1 0001 :1(2^0)          9 1001    
2 0010 :1(2^1)         10 1010
3 0011 :2(2^1+2^0)         11 1011
4 0100 :1(2^2)         12 1100
5 0101 :2(2^2+2^0)
6 0110 :2(2^2)
7 0111 :3(2^2+2^1+2^0)
8 1000 :1

2^0:1,  1(1)
2^1:2,  1(2) + 2(3) = 3  --> 누적 4
2^2:4,  1(4) + 2(5) + 2(6) + 3(7) = 8  --> 누적 12
2^3:8,  1(8) + 2(9) + 2(10)+ 3(11) + 2(12) = 10     --> 누적 22

[1,2^i]까지 구간별 1의 개수에 대한 점화식 : d[i] = 2 * d[i-1] + 2^i
d[0] = 1, d[1] = 4, d[2] = 8, d[3] = 32, ...

'''
import sys
input = sys.stdin.readline

def calc(x):
    cnt = 0
    bin_x = bin(x)[2:]  # x를 이진수로 변환
    length = len(bin_x)
    for i in range(length):
        if bin_x[i] == '1':
            pos = length - i - 1 # i는 0부터 시작되므로 -1을 빼줘야 자리수가 나온다.
            # cnt += dp[pos] + x - (2^pos) + 1
            cnt += dp[pos]  # dp[pos] 보다 작은 1의 개수를 카운트 
            cnt += x - (1 << pos) + 1   # 최상위 비트의 1의 개수 카운트
            x -= (1 << pos) # 2^pos = 1 << pos
    return cnt        

A,B = map(int,input().split())
# 10^16 == 2^50 
# 누적합
dp = [0]*60
for i in range(1,60):
    dp[i] = 2*dp[i-1] + (1 <<(i-1))
# print(dp[1:4])

print(calc(B)-calc(A-1))